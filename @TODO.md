# Auth v2 Overhaul — Single Password + Mandatory Passkeys

Goal: Ship an auth upgrade that removes the cognitive split between "account password" and "master password" for new users, while preserving existing encryption/decryption logic. Mandate passkeys for everyone as a second, convenient unlock and future login option — without breaking current users, flows, or data.

This plan focuses on UX cohesion, safety-first migration, and incremental rollout guarded by flags. No encryption primitives or formats change; we only change when/how we derive/set the master key and how we synchronize the Appwrite login password for existing users.

---

## Constraints and Non‑Goals
- Do not modify crypto primitives or vault encryption/decryption logic.
- Do not change Appwrite database schemas in code directly; schemas live in Appwrite. Types are autogenerated and must not be edited manually.
- Backwards compatibility: existing users must continue to log in and unlock without data loss or extra friction beyond one-time upgrade steps.
- Appwrite does not natively support WebAuthn login; passkey-as-login requires a server-side verifier. In this iteration, passkeys remain a mandatory unlock mechanism and a foundation for future login flows.

---

## High-Level Changes
1. Single secret for new users: the registration password becomes both the Appwrite account password and the master password used for vault key derivation (first-time unlock). No second prompt.
2. Mandatory passkeys: after successful login + first vault unlock, require immediate passkey enrollment (blocking overlay) so passkey can be used for unlock. For existing users without passkeys, gate until they create one.
3. Existing users migration: track a migration flag. After normal login + vault unlock, update their Appwrite login password in the background to equal their master password (no crypto changes). Inform the user that henceforth they will use the master password only for login.
4. Security keys (aka additional passkeys): support up to two extra passkeys as backups. Internally they’re the same as passkeys; expose as “Security Keys”.
5. Future: passkey-based login (not account creation) via a backend verifier/Cloud Function to mint Appwrite sessions. Not in this phase.

---

## Data Model (Appwrite `user` collection)
Add the following fields (managed in Appwrite console; update generated types post-change):
- `authVersion: number` — 1 (legacy), 2 (single-password model).
- `v2Migrated: boolean` — marks existing users who’ve completed background sync (login pw == master pw).
- `mustCreatePasskey: boolean` — enforcement gate at session finalization.
- `passkeys: Array<{ id: string; blob: string; publicKey?: string; counter?: number; label?: string; createdAt: string; lastUsedAt?: string; transports?: string[] }>` — new multi-key store.
- Back-compat fields retained (read-only): `isPasskey`, `passkeyBlob`, `credentialId`, `publicKey`, `counter` — migrate-on-write to `passkeys`.

Notes:
- Do NOT add encryption to these new fields; they are metadata. The wrapped master key blob (`blob`) remains ciphertext produced by client.
- Keep `check` field semantics intact (used to verify master password correctness). We do not change how it’s produced or validated.

---

## Flags and Rollout
- `NEXT_PUBLIC_AUTH_V2_ENABLED` (client): gate new flows and UI copy. Roll out to small cohorts first.
- `NEXT_PUBLIC_PASSKEY_ENFORCE` (client): when true, block navigation until a passkey exists.
- DB-driven enforcement: `mustCreatePasskey` on the user doc overrides client flag for that user.

---

## Current Flow Inventory (where to patch)
- Login: `app/login/page.tsx`
- Register: `app/register/page.tsx`
- Masterpass gate: `app/(protected)/masterpass/page.tsx` + `logic.ts`
- Passkey setup: `components/overlays/passkeySetup.tsx`
- Passkey unlock helper: `app/(protected)/settings/passkey.ts`
- Finalization: `lib/finalizeAuth.ts`, `lib/appwrite.ts` helpers
- Auth context: `app/appwrite-provider.tsx`

---

## New User Flow (Auth v2)
1. Register with email + password (+ optional name) as today.
2. Immediately login (Appwrite session created).
3. First-time vault unlock occurs programmatically using the registration password:
   - Call `masterPassCrypto.unlock(password, userId, true)`;
   - Call `setMasterpassFlag(userId, email)` to set DB flags and write `check` value;
   - Set `authVersion=2`, `v2Migrated=true`, `mustCreatePasskey=true` in user doc.
4. Immediately show a blocking Passkey Setup overlay (cannot dismiss) to enroll a passkey.
   - Optimization: since vault is unlocked, skip re-entering master password inside the overlay (trust unlocked state); keep a fallback path to verify if not unlocked.
5. After passkey created, proceed to dashboard.

Copy updates:
- In Register and Login screens, update labels/descriptions: “Your password is your Master Password.” Remove any suggestion of two separate secrets for new users.

---

## Existing User Migration Flow
Prereq: `authVersion` absent or < 2.
1. User logs in with current Appwrite password (status quo).
2. Masterpass page prompts for master password and unlocks vault (status quo).
3. After unlock, background sync:
   - Update Appwrite account password to equal the master password: `account.updatePassword(newPassword=masterPassword, oldPassword=<the login pw just used>)`.
   - Implementation detail: capture the login password from the login page state and hold it ephemerally in memory (e.g., an in-memory context) only until sync completes; never persist.
   - On success: set `authVersion=2`, `v2Migrated=true`. Show a one-time banner: “From now on, use your Master Password to sign in.”
4. Enforce passkey creation if none:
   - If `passkeys.length === 0` (or legacy `isPasskey !== true`), block with the Passkey Setup overlay until created. Set `mustCreatePasskey=false` after.
5. Don’t alter vault encryption or master password.

Edge cases:
- If the stored old login password is not available (e.g., OTP flow, cross-tab), show a UI prompt to re-enter current account password solely to perform the sync.
- If Appwrite rejects password update (rate limits, policy): retry later and show non-blocking banner; still enforce passkey.

---

## Passkeys and Security Keys
- Rename UI:
  - Primary “Passkey” remains.
  - “Security Keys” are additional passkeys (same mechanism), up to 2 extra backups (max 3 total keys).
- Storage:
  - Migrate from single `credentialId`/`passkeyBlob` to `passkeys[]` lazily:
    - On first successful passkey add/remove, write to `passkeys[]` and keep legacy fields for back-compat.
    - Reading: prefer `passkeys[]` if present; else use legacy fields.
- UX:
  - In Settings → Security: list keys, labels, last used, add/remove; show guidance about backup keys.

---

## Login With Passkey (Future)
- Today: Appwrite lacks native WebAuthn login. Our passkey unlock only decrypts the vault; we still require an Appwrite session via password or email OTP.
- Future plan:
  - Add a backend (Cloud Function or small service) to verify WebAuthn assertions server-side using origin/RP ID, counters, and stored public keys.
  - On success, mint an Appwrite session via Admin API for the user (or issue a one-time token the client can exchange for a session).
  - Strict replay and anti-phishing checks; rotate counters and audit logs.
  - Only enable when backend is audited and deployed. Client already holds enough metadata in `passkeys[]` to enable the flow.

---

## UI/Flow Changes (Implementation Map)
- `app/register/page.tsx`
  - After successful session, automatically perform first-time unlock using registration password; set flags; then gate passkey overlay.
- `app/login/page.tsx`
  - Capture entered password in memory for migration sync; route continues as today.
- `app/(protected)/masterpass/page.tsx`
  - If unlocked and `authVersion<2`, kick off background `updatePassword(masterPassword, oldLoginPassword)`; surface banner on success.
  - Add “Unlock with Passkey” remains (works today).
- `components/overlays/passkeySetup.tsx`
  - Add “trust unlocked vault” mode: if `masterPassCrypto.isVaultUnlocked()`, skip re-entering master password; otherwise, keep existing verification.
  - Add blocking mode; prevent close until success when `mustCreatePasskey` or flag enabled.
  - Add UI to label keys; emit `onSuccess` to refresh user doc.
- `app/(protected)/settings/page.tsx` (or Security section)
  - New “Security Keys” section: list/edit up to 2 backups, remove, rename.
- `lib/appwrite.ts`
  - Add helpers: `markAuthV2(userId)`, `setMustCreatePasskey(userId, boolean)`, `listPasskeys`, `addPasskey`, `removePasskey` that write to `passkeys[]` while preserving legacy fields on write.
  - Add `updateAccountPassword(newPw, oldPw)` wrapper (uses `appwriteAccount.updatePassword`).
  - `getAuthenticationNextRoute` should respect `mustCreatePasskey` and direct to a modal/route gate after unlock.
- `lib/finalizeAuth.ts`
  - After refresh + route selection, if vault unlocked and passkey missing, trigger blocking overlay.
- `app/appwrite-provider.tsx`
  - Provide ephemeral `lastLoginPassword` store (memory-only) for the current tab/session; clear on navigation/logout.

---

## Security Considerations
- Never persist the login password or master password outside of memory; clear references ASAP.
- Continue to store only wrapped master keys (`blob`) and WebAuthn public metadata in DB.
- Preserve `check` semantics and master key lifetime rules (session-only, auto-timeout).
- Enforce passkey creation with a blocking overlay to minimize account lockout risks (users get a backup path if biometrics fail by adding multiple keys).
- Keep OTP and TOTP MFA as-is; passkey is not a replacement for MFA enforcement.
- Add audit logs: log migration completion, passkey add/remove, failed attempts, and password sync status in `securityLogs`.

---

## Edge Cases & Fallbacks
- Password Reset (`/reset-password`): after Appwrite reset completes, prompt to unlock vault with master password and then sync account password to master password (update using `oldPassword = newAppwritePasswordJustSet` → `newPassword = masterPassword`).
- Changing Master Password: existing flows may wipe/rebuild vault; maintain rule to re-sync Appwrite account password to the new master password after reset/recovery.
- OTP sign-in: when login uses email OTP, the "old login password" is unknown; prompt for account password only if needed to perform the one-time sync, or defer until next password-based sign-in.

---

## Telemetry & Observability
- Security logs on user doc actions (`securityLogs` collection):
  - `authV2.migration.started/succeeded/failed`
  - `passkey.added/removed`
  - `password.sync.success/failure`
- Client events (local only or privacy-safe analytics if enabled) for funnel visibility.

---

## Rollout Plan
1. Ship behind `NEXT_PUBLIC_AUTH_V2_ENABLED=false` and DB flags off.
2. Enable for internal accounts; verify migration flow and passkey enforcement.
3. Gradually flip `mustCreatePasskey=true` for new signups; then for cohorts of existing users.
4. Monitor security logs and support channel for issues; provide a temporary bypass (admin-only) if passkey enrollment blocks a user.
5. Later: implement server-side WebAuthn login and roll out passkey-as-login.

---

## Task Breakdown (Checklists)

### A. Schema & Flags
- [ ] Add `authVersion`, `v2Migrated`, `mustCreatePasskey`, `passkeys[]` to Appwrite `user` collection
- [ ] Regenerate `types/appwrite.d.ts` from Appwrite
- [ ] Add `NEXT_PUBLIC_AUTH_V2_ENABLED`, `NEXT_PUBLIC_PASSKEY_ENFORCE`

### B. New Users
- [ ] Auto-unlock vault with registration password (first-time)
- [ ] Set masterpass flag and check value
- [ ] Mark `authVersion=2`, `v2Migrated=true`, `mustCreatePasskey=true`
- [ ] Show blocking Passkey Setup overlay; skip password re-entry if unlocked

### C. Existing Users Migration
- [ ] Capture login password in memory for the current session
- [ ] After masterpass unlock, update Appwrite account password to master password
- [ ] Mark `authVersion=2`, `v2Migrated=true`
- [ ] Inform user via banner/toast
- [ ] Enforce passkey creation if none

### D. Passkeys & Security Keys
- [ ] Migrate to `passkeys[]` model (lazy, with back-compat writes)
- [ ] Update helpers in `lib/appwrite.ts` to add/remove/list keys
- [ ] Settings UI: list keys, labels, add/remove, last-used
- [ ] Enforce max 3 keys (1 primary + 2 backups)

### E. Enforcement & Routing
- [ ] `finalizeAuth`/AppShell gating to require passkey post-unlock
- [ ] Respect DB `mustCreatePasskey` and env flags
- [ ] Do not block MFA; run gate after session + MFA

### F. UX Copy & Education
- [ ] Update Register/Login copy: “Your password is your Master Password”
- [ ] Migration banner for existing users
- [ ] Security Keys explainer and backup guidance

### G. Observability
- [ ] Log migration/passkey events to `securityLogs`
- [ ] Add error handling and retries for password sync

### H. Edge Cases
- [ ] Reset Password flow re-sync to master password
- [ ] OTP-only sign-ins defer sync with gentle prompt
- [ ] Multi-tab handling and clearing ephemeral secrets

### I. Future (Separate PR)
- [ ] Implement backend WebAuthn verifier (Cloud Function)
- [ ] Issue Appwrite session on successful passkey assertion
- [ ] Harden replay/counter checks and origin validation

---

## Open Questions / Decisions
- Should we fully block app usage until passkey is created for all users, or allow a short “remind me later” grace period? (Default: block for new users; grace for legacy with admin override.)
- Labeling: “Passkey” vs “Security key” — align with platform terminology; in UI we show “Passkey” and “Add security key (backup)”.
- Max number of keys (3 total) acceptable? Configurable per user or global?

---

## Risks & Mitigations
- Users who forget master password but have a passkey: vault can still be unlocked via passkey; offer multiple backup keys to reduce lockouts.
- Appwrite password update failures: perform non-blocking retries; never persist old passwords; ask user to retry migration if needed.
- Perception of “login with passkey” without backend: clearly message that passkeys unlock the vault; future update will enable passkey sign-in.

---

## Success Criteria
- New users never see a separate “set master password” step.
- All users end up with at least one passkey enrolled.
- Existing users transparently move to a single-password model (login password == master password) without data loss.
- No changes to encryption format or logic; vault operations unaffected.
